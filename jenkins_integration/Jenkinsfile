#!groovy
@Library('gsdk-shared-lib@master')

def commit_sha = ""
def run_number = ""
def pr_number = ""
def bypass_send_results_gh = ""
pipeline
{
    agent { node { label 'Build-Farm-Large' } }
    options { buildDiscarder(logRotator(artifactNumToKeepStr: '10')) }
    stages {
        stage('Initialize') {
            steps {
                script {
                    pipelineFunctions = load 'jenkins_integration/jenkinsFunctions.groovy'
                    echo "pipelineFunctions loaded: ${pipelineFunctions != null}"
                }
            }
        }
        stage('Static Analysis with SonarQube') {
            steps {
                script {
                    // Declare variables outside the Docker container block
                    def staticAnalysisStatus = ""
                    def staticAnalysisOutput = ""
                    def sonarCommitSha = ""

                    withDockerContainer(image: 'sonarsource/sonar-scanner-cli:latest') {
                        def sonarResult = pipelineFunctions.publishSonarAnalysis()

                        // Extract results for GitHub reporting
                        staticAnalysisStatus = sonarResult.status
                        staticAnalysisOutput = sonarResult.output
                        sonarCommitSha = sonarResult.commit_sha

                        echo "Static Analysis Status: ${staticAnalysisStatus}"
                        echo "Commit SHA from SonarQube: ${sonarCommitSha}"
                    }
                    // Send results to GitHub PR only
                    try {
                        if (env.CHANGE_ID) {
                            pipelineFunctions.send_sonar_results_to_github(
                                sonarCommitSha,
                                staticAnalysisStatus,
                                staticAnalysisOutput,
                                env.CHANGE_ID,
                                env.CHANGE_BRANCH,
                                env.CHANGE_TARGET
                            )
                            echo "✅ Posted SonarQube results to GitHub PR #${env.CHANGE_ID}"
                        } else {
                            echo "ℹ️  Skipping GitHub PR comment (not a PR or bypass enabled)"
                        }
                    } catch (Exception githubEx) {
                        echo "❌ Failed to post to GitHub PR: ${githubEx.getMessage()}"
                    }
                }
            }
        }
        stage('Execute CI Tests')
        {
            steps {
                script {
                    def parallelNodes = [:]
                    if (pr_number != null) {
                        branch_name = "PR-${pr_number}"
                    } else {
                        branch_name = env.BRANCH_NAME
                    }

                    parallelNodes['MG24 Lighting-App'] = {
                        pipelineFunctions.actionWithRetry {
                            failed_tests_mg24 = pipelineFunctions.execute_sanity_tests(
                                'gsdkMontrealNode','utf-matter-thread-4187c-ci',
                                '3251', 'matter_thread_template', 'lighting-app','thread','BRD4187C',"",
                                "tests/test_matter_thread_ci.py", branch_name, run_number)
                        }
                    }

                    parallelNodes['917-SoC Lighting-App'] = {
                        pipelineFunctions.actionWithRetry {
                            failed_tests_917 = pipelineFunctions.execute_sanity_tests(
                                'gsdkMontrealNode','utf-matter-wifi-917soc-4338a-ci', '3249', 'matter_wifi_soc_template',
                                'lighting-app','wifi','BRD4338A','917_soc', "tests/test_matter_wifi_ci.py", branch_name, run_number)
                        }
                    }

                    parallelNodes.failFast = false
                    parallel parallelNodes

                    def totalFailedTests = 0
                    def failedTestsSummary = []

                    if (failed_tests_mg24 && failed_tests_mg24.failedCount > 0) {
                        totalFailedTests += failed_tests_mg24.failedCount
                        failedTestsSummary << "MG24: ${failed_tests_mg24.failedCount} failed tests - ${failed_tests_mg24.failedTests.join(', ')}"
                    }

                    if (failed_tests_917 && failed_tests_917.failedCount > 0) {
                        totalFailedTests += failed_tests_917.failedCount
                        failedTestsSummary << "917: ${failed_tests_917.failedCount} failed tests - ${failed_tests_917.failedTests.join(', ')}"
                    }

                    def sqa_tests_result = totalFailedTests > 0 ? "FAIL" : "PASS"
                    def sqa_tests_summary = failedTestsSummary.isEmpty() ? "All tests passed successfully." : failedTestsSummary.join('\n')

                    echo "SQA Tests Result: ${sqa_tests_result}"
                    echo "SQA Tests Summary:\n${sqa_tests_summary}"

                    echo "commit_sha: ${commit_sha}"
                    if (!bypass_send_results_gh){
                        pipelineFunctions.send_test_results_to_github(commit_sha, sqa_tests_result, sqa_tests_summary)
                    }
                    if (env.BRANCH_NAME.startsWith("main") || env.BRANCH_NAME.startsWith("release_")) {
                        if (sqa_tests_result == "FAIL") {
                            slackSend(channel: 'matter-release-build-notifications',
                                      color: 'danger',
                                      message: "[FAIL] Sanity tests failed for branch ${env.BRANCH_NAME}, Jenkins build number ${env.BUILD_NUMBER}.\n" +
                                               "Commit SHA: ${commit_sha}\nGitHub Workflow Run Number: ${run_number}\n" +
                                               "See summary:\n${sqa_tests_summary}\nJenkins Job URL: ${env.BUILD_URL}")
                            error("[FAIL] Sanity Tests failed. See summary:\n${sqa_tests_summary}")
                        } else {
                            slackSend(channel: 'matter-release-build-notifications',
                                      color: 'good',
                                      message: "[PASS] All tests passed successfully for branch ${env.BRANCH_NAME}, Jenkins build number ${env.BUILD_NUMBER}.\n" +
                                               "Commit SHA: ${commit_sha}\n GitHub Workflow Run Number: ${run_number}\n" +
                                               "Jenkins Job URL: ${env.BUILD_URL}")
                            echo "All tests passed successfully."
                        }
                    }
                }
            }
        }
        stage('Trigger SQA Smoke Pipeline')
        {
            when {
                expression { env.BRANCH_NAME == "main" || env.BRANCH_NAME.startsWith("release_") }
            }
            steps {
                script {
                    pipelineFunctions.trigger_sqa_pipelines("smoke", commit_sha)
                }
            }
       }
       stage('Upload SQA Artifacts') {
            when {
                expression { env.BRANCH_NAME.startsWith("release_") }
            }
            steps {
                script {
                    withDockerContainer(image: 'artifactory.silabs.net/gsdk-docker-production/gsdk_nomad_containers/gsdk_ubai:latest') {
                        def result = pipelineFunctions.upload_artifacts(sqa=true, commit_sha=commit_sha, run_number=run_number)
                    }
                }
            }
        }
        stage('Trigger SQA Regression Pipelines') 
        {
            when {
                expression {  env.BRANCH_NAME.startsWith("release_") }
            }
            steps {
                script {
                    pipelineFunctions.trigger_sqa_pipelines("regression", commit_sha)
                }
            }
       }
    }
}